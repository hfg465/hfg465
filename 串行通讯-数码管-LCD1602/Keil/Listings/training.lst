C51 COMPILER V9.60.0.0   TRAINING                                                          10/20/2021 22:18:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TRAINING
OBJECT MODULE PLACED IN .\Objects\training.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE training.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -training.lst) TABS(2) OBJECT(.\Objects\training.obj)

line level    source

   1          #include<reg52.h>
   2          #include<intrins.h>
   3          #include"training_main.h"
   4          #include"lcd_1602.h"
   5          
   6          /*单片机初始化*/
   7          void init_51c()
   8          {
   9   1        EA=1;                   //中断允许总 开
  10   1        ES=1;                   //串行中断允许 开
  11   1        EX0=1;                  //外部中断0允许
  12   1        TMOD=0x20;              //设定 定时器1 的工作方式 1
  13   1        SM0=0;
  14   1        SM1=1;                  //串行口工作方式 1
  15   1        REN=1;                  //允许串行口接收数据
  16   1        TH1=0xfd;
  17   1        TL1=0xfd;               //设定初值，波特率为 9600 bps
  18   1        TR1=1;                  //启动定时器
  19   1        seg_ch=0;               //数码管片选端选择开
  20   1        seg=seg_tab[key];       //数码管显示初始化
  21   1        IT0=0;                  //外部中断0低电平触发
  22   1        P0=0xf0;                //矩阵键盘低四位送低电平
  23   1      }
  24          
  25          /*主函数入口*/
  26          void main()
  27          {
  28   1        uchar key0=0;      //用于判断键值是否更新，若发生更新再发送新的键值，若没有更新则不发送
  29   1        init_51c();
  30   1        lcd_init();
  31   1        while(1)
  32   1        {
  33   2          seg=seg_tab[key];            //数码管显示键值
  34   2          if(key0!=key)
  35   2          {
  36   3            ES=0;
  37   3            SBUF=key;                    //发送键值
  38   3            while(!TI);                  //等待发送完成
  39   3            TI=0;
  40   3            ES=1;
  41   3            key0=key;
  42   3          }
  43   2          if(flag==1)
  44   2          {
  45   3            ES=0;
  46   3            wr_data(aa);
  47   3            if(aa=='.')wr_cmd(0x02);       //LCD指针数据清零
  48   3            flag=0;
  49   3            ES=1;
  50   3          }
  51   2        }
  52   1      }
  53          
  54          /* INT0 中断 */
C51 COMPILER V9.60.0.0   TRAINING                                                          10/20/2021 22:18:10 PAGE 2   

  55          void m_kb() interrupt 0
  56          {
  57   1        uchar ret;
  58   1        delay(8);
  59   1        if(P0!=0xf0)
  60   1        {
  61   2          P0=0xfe;                      // 1
  62   2          ret=P0&0xf0;
  63   2          if(ret!=0xf0)
  64   2          {
  65   3            switch(ret)
  66   3            {
  67   4              case 0xe0:key=0;break;
  68   4              case 0xd0:key=1;break;
  69   4              case 0xb0:key=2;break;
  70   4              case 0x70:key=3;break;
  71   4              default:key=16;
  72   4            }
  73   3            while(ret!=0xf0)               //等待按键释放
  74   3            {
  75   4              P0=0xfe;
  76   4              ret=P0&0xf0;
  77   4            }
  78   3          }
  79   2          P0=0xfd;                      // 2
  80   2          ret=P0&0xf0;
  81   2          if(ret!=0xf0)
  82   2          {
  83   3            switch(ret)
  84   3            {
  85   4              case 0xe0:key=4;break;
  86   4              case 0xd0:key=5;break;
  87   4              case 0xb0:key=6;break;
  88   4              case 0x70:key=7;break;
  89   4              default:key=16;
  90   4            }
  91   3            while(ret!=0xf0)               //等待按键释放
  92   3            {
  93   4              P0=0xfd;
  94   4              ret=P0&0xf0;
  95   4            }
  96   3          }
  97   2          P0=0xfb;                      // 3
  98   2          ret=P0&0xf0;
  99   2          if(ret!=0xf0)
 100   2          {
 101   3            switch(ret)
 102   3            {
 103   4              case 0xe0:key=8;break;
 104   4              case 0xd0:key=9;break;
 105   4              case 0xb0:key=10;break;
 106   4              case 0x70:key=11;break;
 107   4              default:key=16;
 108   4            }
 109   3            while(ret!=0xf0)               //等待按键释放
 110   3            {
 111   4              P0=0xfb;
 112   4              ret=P0&0xf0;
 113   4            }
 114   3          }
 115   2          P0=0xf7;                      // 4
 116   2          ret=P0&0xf0;
C51 COMPILER V9.60.0.0   TRAINING                                                          10/20/2021 22:18:10 PAGE 3   

 117   2          if(ret!=0xf0)
 118   2          {
 119   3            switch(ret)
 120   3            {
 121   4              case 0xe0:key=12;break;
 122   4              case 0xd0:key=13;break;
 123   4              case 0xb0:key=14;break;
 124   4              case 0x70:key=15;break;
 125   4              default:key=16;
 126   4            }
 127   3            while(ret!=0xf0)               //等待按键释放
 128   3            {
 129   4              P0=0xf7;
 130   4              ret=P0&0xf0;
 131   4            }
 132   3          }   
 133   2        }
 134   1        P0=0xf0;
 135   1      }
 136          
 137          /*串行口接收中断*/
 138          void rec() interrupt 4
 139          {
 140   1        RI=0;
 141   1        aa=SBUF;
 142   1        flag=1;
 143   1      }
 144          
 145          /* ms延时函数 */
 146          /*
 147          void delay(uint x_ms)
 148          {
 149            for(i=x_ms;i>0;i--)
 150              for(j=113;j>0;j--);
 151          }
 152          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    455    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
